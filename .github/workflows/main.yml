name: Generate PR Summary

on:
  pull_request:
    types: [closed]
    branches:
      - main
      - NewClaudeChanges
      - Testtes
  workflow_dispatch:  # Allow manual testing

jobs:
  generate-summary:
    runs-on: ubuntu-latest
    # Only run if the PR was actually merged (not just closed)
    if: github.event.pull_request.merged == true
    permissions:
      contents: read
      pull-requests: write  # Needed to comment on PRs
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for better diff context
          
      - name: Get PR details
        id: pr-details
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            
            // Get PR basic info
            const prInfo = {
              number: pr.number,
              title: pr.title,
              body: pr.body,
              author: pr.user.login,
              base_branch: pr.base.ref,
              head_branch: pr.head.ref,
              created_at: pr.created_at,
              updated_at: pr.updated_at
            };
            
            // Get list of changed files
            const files = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number
            });
            
            const fileChanges = files.data.map(file => ({
              filename: file.filename,
              status: file.status,
              additions: file.additions,
              deletions: file.deletions,
              changes: file.changes,
              patch: file.patch  // The actual diff
            }));
            
            // Get commits
            const commits = await github.rest.pulls.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number
            });
            
            const commitMessages = commits.data.map(c => ({
              sha: c.sha.substring(0, 7),
              message: c.commit.message,
              author: c.commit.author.name
            }));
            
            const output = {
              pr: prInfo,
              files: fileChanges,
              commits: commitMessages,
              stats: {
                total_files: files.data.length,
                total_additions: files.data.reduce((sum, f) => sum + f.additions, 0),
                total_deletions: files.data.reduce((sum, f) => sum + f.deletions, 0)
              }
            };
            
            // Save to file for next step
            const fs = require('fs');
            fs.writeFileSync('pr-data.json', JSON.stringify(output, null, 2));
            
            return output;
      
      - name: Generate AI Summary
        id: ai-summary
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_KEY }}
        run: |
          # Read the PR data
          PR_DATA=$(cat pr-data.json)
          
          # Create prompt for Claude
          PROMPT="You are a technical reviewer with 10 years of experience. Generate a concise technical summary of this pull request.
          
          PR Data:
          $PR_DATA
          
          Please provide:
          1. A brief overview of what this PR does
          2. Key technical changes
          3. Files modified and their purpose
          4. Any potential concerns or areas for review
          
          Keep it concise and technical. Format your response as plain text without any special formatting."
          
          # Call Claude API
          RESPONSE=$(curl -s https://api.anthropic.com/v1/messages \
            -H "Content-Type: application/json" \
            -H "x-api-key: $ANTHROPIC_API_KEY" \
            -H "anthropic-version: 2023-06-01" \
            -d @- << EOF
          {
            "model": "claude-3-5-sonnet-20241022",
            "max_tokens": 1024,
            "messages": [{
              "role": "user",
              "content": $(echo "$PROMPT" | jq -Rs .)
            }]
          }
          EOF
          )
          
          # Extract summary from response
          SUMMARY=$(echo "$RESPONSE" | jq -r '.content[0].text')
          
          # Save summary
          echo "$SUMMARY" > summary.txt
          echo "summary<<EOF" >> $GITHUB_OUTPUT
          echo "$SUMMARY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          # Also save PR number and title for Confluence
          echo "pr_number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
          echo "pr_title=${{ github.event.pull_request.title }}" >> $GITHUB_OUTPUT
          echo "pr_url=${{ github.event.pull_request.html_url }}" >> $GITHUB_OUTPUT
      
      - name: Comment on PR
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const summary = fs.readFileSync('summary.txt', 'utf8');
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: `## ü§ñ AI-Generated PR Summary\n\n${summary}\n\n---\n*Generated by Claude 3.5 Sonnet*`
            });
      
      - name: Push to Confluence (v2 atlas_doc_format with collapsibles)
        env:
          CONFLUENCE_BASE: https://method.atlassian.net/wiki/api/v2
          CONFLUENCE_USER: a.awasthi@method.me
          CONFLUENCE_API_TOKEN: ${{ secrets.ATLASSIAN_TOKEN }}
          CONFLUENCE_PAGE_ID: 198869144
        run: |
          set -euo pipefail

          # Inputs
          SUMMARY=$(cat summary.txt || true)
          if [ -z "$SUMMARY" ]; then
            echo "‚ùå Empty summary; aborting Confluence update."
            exit 1
          fi

          PR_NUMBER="${{ steps.ai-summary.outputs.pr_number }}"
          PR_TITLE="${{ steps.ai-summary.outputs.pr_title }}"
          PR_URL="${{ steps.ai-summary.outputs.pr_url }}"
          MERGED_AT="${{ github.event.pull_request.merged_at }}"
          MERGED_BY="${{ github.event.pull_request.merged_by.login }}"

          AUTH="$CONFLUENCE_USER:$CONFLUENCE_API_TOKEN"
          PAGE_ID="$CONFLUENCE_PAGE_ID"
          BASE="$CONFLUENCE_BASE"

          echo "Fetching Confluence page (v2 + ADF)‚Ä¶"
          PAGE=$(
            curl -fS -u "$AUTH" \
              -G "$BASE/pages/$PAGE_ID" \
              --data-urlencode "body-format=atlas_doc_format"
          )

          VERSION=$(echo "$PAGE" | jq -r '.version.number')
          TITLE=$(echo "$PAGE"   | jq -r '.title')
          ADF_STR=$(echo "$PAGE" | jq -r '.body.atlas_doc_format.value // empty')

          # If page has no ADF yet, start with minimal doc
          if [ -z "$ADF_STR" ] || [ "$ADF_STR" = "null" ]; then
            ADF='{"version":1,"type":"doc","content":[{"type":"paragraph"}]}'
          else
            ADF=$(echo "$ADF_STR" | jq -r '.')
          fi

          # JSON-safe raw strings
          SUMMARY_RAW=$(printf "%s" "$SUMMARY" | jq -Rs .)
          PR_LINK_TEXT=$(printf "View PR #%s" "$PR_NUMBER")

          # Helper: build a paragraph from newline text using hardBreaks
          summaryPara() {
            jq -n --argjson s "$SUMMARY_RAW" '
              def summaryPara($s):
                ( $s | split("\n") ) as $lines
                | {
                    type:"paragraph",
                    content: (
                      [ foreach ( $lines | to_entries[] ) as $i
                          ( [];
                            . + [ {type:"text", text: $lines[$i.key]} ]
                              + ( if $i.key < ($lines|length - 1) then [ {type:"hardBreak"} ] else [] end )
                          )
                      ] | add
                    )
                  };
              summaryPara($s)
            '
          }

          SUMMARY_PARA=$(summaryPara)

          # Build nodes to append:
          # - H3 heading
          # - Expand "AI Summary" (contains the paragraph w/ hardBreaks)
          # - Expand "Merge metadata" (optional tidy metadata)
          # - Link paragraph
          # - Divider
          NEW_CONTENT=$(
            jq -n \
              --arg pr_num "$PR_NUMBER" \
              --arg pr_title "$PR_TITLE" \
              --arg pr_url "$PR_URL" \
              --arg merged_at "$MERGED_AT" \
              --arg merged_by "$MERGED_BY" \
              --arg pr_link_text "$PR_LINK_TEXT" \
              --argjson summary_para "$SUMMARY_PARA" '
              def linkPara($text; $href):
                { type:"paragraph",
                  content:[ {type:"text", text:$text, marks:[{type:"link", attrs:{href:$href}}]} ]
                };

              [
                { type:"heading", attrs:{level:3},
                  content:[{type:"text", text: ("PR #" + $pr_num + ": " + $pr_title)}]
                },

                { type:"expand", attrs:{title:"AI Summary"},
                  content:[ $summary_para ]
                },

                { type:"expand", attrs:{title:"Merge metadata"},
                  content:[
                    { type:"paragraph",
                      content:[{type:"text", text: ("Merged on " + $merged_at + " by " + $merged_by)}]
                    }
                  ]
                },

                linkPara($pr_link_text, $pr_url),

                { type:"rule" }
              ]
            '
          )

          # Append new nodes to existing ADF
          NEW_ADF=$(jq --argjson add "$NEW_CONTENT" '.content += $add' <<< "$ADF")

          # Build update payload (v2 requires value as STRINGIFIED JSON)
          UPDATE=$(
            jq -n \
              --arg title "$TITLE" \
              --argjson value "$NEW_ADF" \
              --argjson ver $((VERSION + 1)) '
              {
                "title": $title,
                "status": "current",
                "version": { "number": $ver },
                "body": {
                  "atlas_doc_format": {
                    "value": ($value | tostring),
                    "representation": "atlas_doc_format"
                  }
                }
              }'
          )

          echo "Updating Confluence page‚Ä¶"
          curl -fS -u "$AUTH" -X PUT "$BASE/pages/$PAGE_ID" \
            -H "Content-Type: application/json" \
            -d "$UPDATE" \
            | jq . > /dev/null

          
          # Check if update was successful
          if echo "$UPDATE_RESPONSE" | jq -e '.id' > /dev/null 2>&1; then
            echo "‚úÖ Successfully added collapsible PR #$PR_NUMBER to Confluence page"
          else
            echo "‚ùå Error updating Confluence page"
            echo "Response: $UPDATE_RESPONSE"
            exit 1
          fi
